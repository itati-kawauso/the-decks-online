<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE DECKS Online v2.6</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #2c3e50; color: white; display: flex; flex-direction: column; align-items: center; margin: 0; padding-bottom: 20px;}
        #connection-panel { background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px; margin: 20px; border: 2px solid #f1c40f; text-align: center; width: 90%; max-width: 400px; }
        #game-board { width: 95%; max-width: 1000px; display: none; flex-direction: column; gap: 10px; margin-top: 20px;}
        .player-area { border: 2px solid #7f8c8d; padding: 10px; border-radius: 10px; background: #34495e; position: relative; transition: all 0.3s; }
        .active-area { border-color: #f1c40f; box-shadow: 0 0 20px rgba(241, 196, 15, 0.4); }
        .stats { display: flex; justify-content: space-around; font-weight: bold; margin-bottom: 5px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; font-size: 13px;}
        .field, .hand { display: flex; flex-wrap: wrap; gap: 8px; min-height: 110px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 5px; margin-top: 5px; align-items: center; justify-content: center;}
        .card { width: 60px; height: 85px; background: white; color: black; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; border: 3px solid transparent; user-select: none; transition: all 0.2s; position: relative; }
        .card.red { color: #e74c3c; }
        .card.back { background: #2980b9 !important; border-color: #3498db; }
        .card.tapped { transform: rotate(10deg); opacity: 0.7; background: #bdc3c7; }
        .card.selected { border-color: #3498db; transform: translateY(-5px); box-shadow: 0 5px 15px rgba(52, 152, 219, 0.6); z-index: 10; }
        .suit { font-size: 20px; }
        .controls { margin: 15px; display: none; flex-wrap: wrap; gap: 8px; background: #1a252f; padding: 15px; border-radius: 10px; width: 95%; max-width: 980px; justify-content: center;}
        .log-container { width: 95%; max-width: 1000px; height: 140px; background: #000; border: 2px solid #7f8c8d; border-radius: 5px; overflow-y: scroll; padding: 10px; box-sizing: border-box; display: none;}
        .log-entry { margin-bottom: 4px; font-family: monospace; font-size: 11px; border-bottom: 1px solid #222; color: #ccc;}
        button { padding: 8px 12px; cursor: pointer; font-weight: bold; border-radius: 5px; border: none; background: #ecf0f1; }
        button.primary { background: #f1c40f; color: #000; }
        button.active-mode { background: #f1c40f !important; box-shadow: 0 0 10px #f1c40f; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 200; flex-direction: column; align-items: center; justify-content: center; }
        .modal-content { background: #34495e; padding: 25px; border-radius: 10px; text-align: center; border: 2px solid #f1c40f; width: 90%; max-width: 500px; }
        .direct-attack-btn { background: #e74c3c; color: white; padding: 8px 15px; border-radius: 5px; border: 2px solid white; cursor: pointer; font-weight: bold; display: none; margin: 5px auto; }
    </style>
</head>
<body>

<h1>THE DECKS Online</h1>

<div id="connection-panel">
    <div id="status">Peer準備中...</div>
    <div id="my-id-display" style="margin: 10px 0; font-size: 12px; color: #f1c40f;"></div>
    <div id="setup-controls">
        <button onclick="hostGame()" class="primary">部屋を作る (Host)</button>
        <div style="margin-top: 15px;">
            <input id="join-id" placeholder="相手のIDを入力" style="padding: 8px; border-radius: 5px; width: 70%;">
            <button onclick="joinGame()">参加</button>
        </div>
    </div>
</div>

<div id="mode-selection-modal" class="modal">
    <div class="modal-content">
        <h2>ルール設定</h2>
        <div id="mode-options">
            <button class="primary" onclick="requestRuleMode('basic')">基本ルールのみ</button>
            <button class="primary" onclick="requestRuleMode('style')">採用型ルールあり</button>
        </div>
        <p id="guest-wait-msg" style="display:none; color:#f1c40f; margin-top:20px;">ホストがルールを選択中です...</p>
    </div>
</div>

<div id="setup-modal" class="modal">
    <div class="modal-content">
        <h2>スタイル選択</h2>
        <div id="style-list"></div>
        <button id="style-ready-btn" class="primary" onclick="readyWithStyles()">準備完了</button>
        <p id="waiting-msg" style="display:none; color:#f1c40f;">相手の準備を待っています...</p>
    </div>
</div>

<div id="game-board">
    <div id="opp-area" class="player-area">
        <div class="stats">ENEMY | Deck: <span id="opp-deck">0</span> | AP: <span id="opp-ap">0</span></div>
        <!-- ボタンをfieldの外側に移動 -->
        <button id="direct-btn" class="direct-attack-btn" onclick="executeDirectAttack()">直接攻撃！</button>
        <div id="opp-field" class="field"></div>
        <div id="opp-hand" class="hand"></div>
    </div>
    <div id="my-area" class="player-area">
        <div class="stats">YOU | Deck: <span id="my-deck">0</span> | AP: <span id="my-ap">0</span></div>
        <div id="my-field" class="field"></div>
        <div id="my-hand" class="hand"></div>
    </div>
</div>

<div class="controls" id="game-controls">
    <button id="btn-SUMMON" onclick="setMode('SUMMON')">招集(1)</button>
    <button id="btn-ATTACK" onclick="setMode('ATTACK')">攻撃(1)</button>
    <button id="btn-WITHDRAW" onclick="setMode('WITHDRAW')">撤退</button>
    <button class="primary" onclick="endTurn()">ターン終了</button>
</div>
<div id="game-log" class="log-container"></div>

<script>
const SUITS = { S: '♠', H: '♥', C: '♣', D: '♦', J: '★' };
let peer, conn, isHost = false, myRole = null; 
let gameState = { p1: null, p2: null, turn: 1, started: false };
let currentMode = 'IDLE', selectedCards = [];

peer = new Peer();
peer.on('open', id => { document.getElementById('my-id-display').innerText = "ID: " + id; document.getElementById('status').innerText = "準備完了"; });
peer.on('connection', c => { conn = c; isHost = true; myRole = 'p1'; setupConn(); });

function hostGame() { document.getElementById('setup-controls').innerText = "待機中..."; }
function joinGame() { const id = document.getElementById('join-id').value; if(id) { conn = peer.connect(id); isHost = false; myRole = 'p2'; setupConn(); } }

function setupConn() {
    conn.on('open', () => {
        document.getElementById('connection-panel').style.display = 'none';
        document.getElementById('mode-selection-modal').style.display = 'flex';
        if(!isHost) document.getElementById('mode-options').style.display = 'none';
        if(!isHost) document.getElementById('guest-wait-msg').style.display = 'block';
    });
    conn.on('data', data => handleData(data));
}

function handleData(data) {
    if(data.type === 'RULE_SELECT') {
        gameState.ruleMode = data.payload;
        document.getElementById('mode-selection-modal').style.display = 'none';
        if(gameState.ruleMode === 'style') { document.getElementById('setup-modal').style.display = 'flex'; }
        else if(isHost) initGame();
    }
    if(data.type === 'SYNC') { 
        gameState = data.payload; 
        if(gameState.started) { showGameBoardUI(); updateUI(); }
    }
    if(data.type === 'ACTION' && isHost) {
        if(data.payload.type === 'END_TURN') endTurn();
        else executeAction(data.payload.type, data.payload.params);
        sync();
    }
}

function requestRuleMode(m) { if(isHost) { send('RULE_SELECT', m); handleData({type:'RULE_SELECT', payload:m}); } }

function initGame() {
    gameState.started = true;
    gameState.p1 = { deck: createDeck(['S', 'H']), hand: [], field: [], ap: 0 };
    gameState.p2 = { deck: createDeck(['C', 'D']), hand: [], field: [], ap: 0 };
    for(let i=0; i<3; i++) { 
        if(gameState.p1.deck.length > 0) gameState.p1.hand.push(gameState.p1.deck.pop()); 
        if(gameState.p2.deck.length > 0) gameState.p2.hand.push(gameState.p2.deck.pop()); 
    }
    gameState.turn = 1;
    startTurn();
}

function startTurn() {
    const p = (gameState.turn === 1 ? gameState.p1 : gameState.p2);
    for(let i=0; i<2; i++) if(p.deck.length > 0) p.hand.push(p.deck.pop());
    p.ap = Math.min(p.hand.length, 10);
    p.field.forEach(c => c.tapped = false);
    sync();
}

function sync() { if(isHost) send('SYNC', gameState); updateUI(); }
function send(type, payload) { if(conn && conn.open) conn.send({type, payload}); }

function showGameBoardUI() {
    document.getElementById('mode-selection-modal').style.display = 'none';
    document.getElementById('setup-modal').style.display = 'none';
    document.getElementById('game-board').style.display = 'flex';
    document.getElementById('game-controls').style.display = 'flex';
    document.getElementById('game-log').style.display = 'block';
}

function updateUI() {
    if(!gameState.started || !gameState.p1 || !gameState.p2) return;
    const me = (myRole === 'p1' ? gameState.p1 : gameState.p2);
    const opp = (myRole === 'p1' ? gameState.p2 : gameState.p1);

    document.getElementById('my-deck').innerText = me.deck.length;
    document.getElementById('my-ap').innerText = me.ap;
    document.getElementById('opp-deck').innerText = opp.deck.length;
    document.getElementById('opp-ap').innerText = opp.ap;

    renderCards('my-hand', me.hand, false, 'me', 'hand');
    renderCards('my-field', me.field, false, 'me', 'field');
    renderCards('opp-hand', opp.hand, true, 'opp', 'hand');
    renderCards('opp-field', opp.field, false, 'opp', 'field');

    const myTurn = (gameState.turn === (myRole === 'p1' ? 1 : 2));
    document.getElementById('my-area').className = 'player-area' + (myTurn ? ' active-area' : '');
    document.getElementById('opp-area').className = 'player-area' + (!myTurn ? ' active-area' : '');

    // 安全に直接攻撃ボタンを操作
    const directBtn = document.getElementById('direct-btn');
    if(directBtn) {
        directBtn.style.display = (myTurn && currentMode === 'ATTACK' && selectedCards.length > 0 && opp.field.length === 0) ? 'block' : 'none';
    }
}

function renderCards(id, cards, isBack, owner, area) {
    const container = document.getElementById(id); 
    if(!container) return;
    container.innerHTML = ''; // ここで中身を空にしても direct-btn は外にあるので安全
    if(!cards) return;
    cards.forEach((c, i) => {
        const div = document.createElement('div');
        div.className = isBack ? 'card back' : `card ${c.red ? 'red' : ''} ${c.tapped ? 'tapped' : ''}`;
        if(!isBack) {
            if(owner === 'me' && area === 'field' && selectedCards.includes(i)) div.classList.add('selected');
            let val = c.isJoker ? 'JOK' : (c.rank === 1 ? 'A' : (c.rank === 11 ? 'J' : (c.rank === 12 ? 'Q' : (c.rank === 13 ? 'K' : c.rank))));
            div.innerHTML = `<div class="suit">${SUITS[c.suit]}</div><div>${val}</div>`;
        }
        div.onclick = () => handleCardClick(owner, area, i);
        container.appendChild(div);
    });
}

function handleCardClick(owner, area, idx) {
    if(gameState.turn !== (myRole === 'p1' ? 1 : 2)) return;
    if(owner === 'me') {
        if(currentMode === 'SUMMON' && area === 'hand') requestAction('SUMMON', {idx});
        if(currentMode === 'WITHDRAW' && area === 'field') requestAction('WITHDRAW', {idx});
        if(currentMode === 'ATTACK' && area === 'field') {
            if(selectedCards.includes(idx)) selectedCards = selectedCards.filter(i => i !== idx);
            else selectedCards.push(idx);
            updateUI();
        }
    } else if(currentMode === 'ATTACK' && area === 'field' && selectedCards.length > 0) {
        requestAction('COMBAT', {atkIdxs: selectedCards, defIdx: idx});
        selectedCards = [];
    }
}

function requestAction(type, params) { if(isHost) { executeAction(type, params); sync(); } else { send('ACTION', {type, params}); } }

function executeAction(type, params) {
    const p = (gameState.turn === 1 ? gameState.p1 : gameState.p2);
    const opp = (gameState.turn === 1 ? gameState.p2 : gameState.p1);
    if(type === 'SUMMON' && p.ap > 0) { p.field.push(p.hand.splice(params.idx, 1)[0]); p.ap--; }
    else if(type === 'WITHDRAW') {
        const c = p.field.splice(params.idx, 1)[0];
        const cost = c.tapped ? 2 : 1;
        if(p.ap >= cost) { p.deck.unshift(c); p.ap -= cost; } else p.field.splice(params.idx, 0, c);
    }
    else if(type === 'COMBAT' && p.ap > 0) {
        const attackers = params.atkIdxs.map(i => p.field[i]);
        const defender = opp.field[params.defIdx];
        attackers.forEach(c => c.tapped = true); p.ap--;
        const atkPower = attackers.reduce((s,c) => s + c.rank, 0);
        if(attackers[0].red !== defender.red || atkPower >= defender.rank) {
            opp.field.splice(params.defIdx, 1);
            if(attackers[0].red === defender.red) { if(opp.deck.length>0) opp.hand.push(opp.deck.pop()); }
        }
    }
    else if(type === 'DIRECT' && p.ap > 0) {
        params.idxs.forEach(i => p.field[i].tapped = true);
        p.ap--; 
        for(let i=0; i<2; i++) if(opp.deck.length>0) opp.hand.push(opp.deck.pop());
    }
}

function executeDirectAttack() { if(selectedCards.length > 0) { requestAction('DIRECT', {idxs: selectedCards}); selectedCards = []; currentMode = 'IDLE'; } }
function endTurn() { if(isHost) { gameState.turn = (gameState.turn === 1 ? 2 : 1); startTurn(); } else send('ACTION', {type:'END_TURN'}); currentMode = 'IDLE'; selectedCards = []; }
function setMode(m) { currentMode = (currentMode === m) ? 'IDLE' : m; selectedCards = []; updateUI(); }
function createDeck(suits) { 
    let d = []; suits.forEach(s => { for(let r=1; r<=13; r++) d.push({suit:s, rank:r, red:(s==='H'||s==='D'), tapped:false}); });
    d.push({suit:'J', rank:14, isJoker:true, red:null, tapped:false});
    return d.sort(() => Math.random() - 0.5); 
}
</script>
</body>
</html>
